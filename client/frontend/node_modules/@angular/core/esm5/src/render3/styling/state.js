import { TEMPLATE_DIRECTIVE_INDEX } from '../util/styling_utils';
// these values will get filled in the very first time this is accessed...
var _state = {
    element: null,
    directiveIndex: -1,
    sourceIndex: -1,
    classesBitMask: -1,
    classesIndex: -1,
    stylesBitMask: -1,
    stylesIndex: -1,
};
var BIT_MASK_START_VALUE = 0;
// the `0` start value is reserved for [map]-based entries
var INDEX_START_VALUE = 1;
/**
 * Returns (or instantiates) the styling state for the given element.
 *
 * Styling state is accessed and processed each time a style or class binding
 * is evaluated.
 *
 * If and when the provided `element` doesn't match the current element in the
 * state then this means that styling was recently cleared or the element has
 * changed in change detection. In both cases the styling state is fully reset.
 *
 * If and when the provided `directiveIndex` doesn't match the current directive
 * index in the state then this means that a new source has introduced itself into
 * the styling code (or, in other words, another directive or component has started
 * to apply its styling host bindings to the element).
 */
export function getStylingState(element, directiveIndex) {
    if (_state.element !== element) {
        _state.element = element;
        _state.directiveIndex = directiveIndex;
        _state.sourceIndex = directiveIndex === TEMPLATE_DIRECTIVE_INDEX ? 0 : 1;
        _state.classesBitMask = BIT_MASK_START_VALUE;
        _state.classesIndex = INDEX_START_VALUE;
        _state.stylesBitMask = BIT_MASK_START_VALUE;
        _state.stylesIndex = INDEX_START_VALUE;
    }
    else if (_state.directiveIndex !== directiveIndex) {
        _state.directiveIndex = directiveIndex;
        _state.sourceIndex++;
    }
    return _state;
}
/**
 * Clears the styling state so that it can be used by another element's styling code.
 */
export function resetStylingState() {
    _state.element = null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL3N0eWxpbmcvc3RhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBUUEsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFxRC9ELDBFQUEwRTtBQUMxRSxJQUFNLE1BQU0sR0FBaUI7SUFDM0IsT0FBTyxFQUFFLElBQUk7SUFDYixjQUFjLEVBQUUsQ0FBQyxDQUFDO0lBQ2xCLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFDZixjQUFjLEVBQUUsQ0FBQyxDQUFDO0lBQ2xCLFlBQVksRUFBRSxDQUFDLENBQUM7SUFDaEIsYUFBYSxFQUFFLENBQUMsQ0FBQztJQUNqQixXQUFXLEVBQUUsQ0FBQyxDQUFDO0NBQ2hCLENBQUM7QUFFRixJQUFNLG9CQUFvQixHQUFHLENBQUMsQ0FBQztBQUUvQiwwREFBMEQ7QUFDMUQsSUFBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7QUFFNUI7Ozs7Ozs7Ozs7Ozs7O0dBY0c7QUFDSCxNQUFNLFVBQVUsZUFBZSxDQUFDLE9BQWlCLEVBQUUsY0FBc0I7SUFDdkUsSUFBSSxNQUFNLENBQUMsT0FBTyxLQUFLLE9BQU8sRUFBRTtRQUM5QixNQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN6QixNQUFNLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztRQUN2QyxNQUFNLENBQUMsV0FBVyxHQUFHLGNBQWMsS0FBSyx3QkFBd0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekUsTUFBTSxDQUFDLGNBQWMsR0FBRyxvQkFBb0IsQ0FBQztRQUM3QyxNQUFNLENBQUMsWUFBWSxHQUFHLGlCQUFpQixDQUFDO1FBQ3hDLE1BQU0sQ0FBQyxhQUFhLEdBQUcsb0JBQW9CLENBQUM7UUFDNUMsTUFBTSxDQUFDLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQztLQUN4QztTQUFNLElBQUksTUFBTSxDQUFDLGNBQWMsS0FBSyxjQUFjLEVBQUU7UUFDbkQsTUFBTSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7UUFDdkMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ3RCO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLGlCQUFpQjtJQUMvQixNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUN4QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIEBsaWNlbnNlXG4qIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuKlxuKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4qL1xuaW1wb3J0IHtSRWxlbWVudH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9yZW5kZXJlcic7XG5pbXBvcnQge1RFTVBMQVRFX0RJUkVDVElWRV9JTkRFWH0gZnJvbSAnLi4vdXRpbC9zdHlsaW5nX3V0aWxzJztcblxuLyoqXG4gKiAtLS0tLS0tLVxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbGwgc3RhdGUtYmFzZWQgbG9naWMgZm9yIHN0eWxpbmcgaW4gQW5ndWxhci5cbiAqXG4gKiBTdHlsaW5nIGluIEFuZ3VsYXIgaXMgZXZhbHVhdGVkIHdpdGggYSBzZXJpZXMgb2Ygc3R5bGluZy1zcGVjaWZpY1xuICogdGVtcGxhdGUgaW5zdHJ1Y3Rpb25zIHdoaWNoIGFyZSBjYWxsZWQgb25lIGFmdGVyIGFub3RoZXIgZWFjaCB0aW1lXG4gKiBjaGFuZ2UgZGV0ZWN0aW9uIG9jY3VycyBpbiBBbmd1bGFyLlxuICpcbiAqIFN0eWxpbmcgbWFrZXMgdXNlIG9mIHZhcmlvdXMgdGVtcG9yYXJ5LCBzdGF0ZS1iYXNlZCB2YXJpYWJsZXMgYmV0d2VlblxuICogaW5zdHJ1Y3Rpb25zIHNvIHRoYXQgaXQgY2FuIGJldHRlciBjYWNoZSBhbmQgb3B0aW1pemUgaXRzIHZhbHVlcy5cbiAqIFRoZXNlIHZhbHVlcyBhcmUgdXN1YWxseSBwb3B1bGF0ZWQgYW5kIGNsZWFyZWQgd2hlbiBhbiBlbGVtZW50IGlzXG4gKiBleGl0ZWQgaW4gY2hhbmdlIGRldGVjdGlvbiAob25jZSBhbGwgdGhlIGluc3RydWN0aW9ucyBhcmUgcnVuIGZvclxuICogdGhhdCBlbGVtZW50KS5cbiAqXG4gKiBUbyBsZWFybiBtb3JlIGFib3V0IHRoZSBhbGdvcml0aG0gc2VlIGBUU3R5bGluZ0NvbnRleHRgLlxuICpcbiAqIC0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBVc2VkIGFzIGEgc3RhdGUgcmVmZXJlbmNlIGZvciB1cGRhdGUgdmFsdWVzIGJldHdlZW4gc3R5bGUvY2xhc3MgYmluZGluZyBpbnN0cnVjdGlvbnMuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gc3RvcmluZyB0aGUgZWxlbWVudCBhbmQgYml0LW1hc2sgcmVsYXRlZCB2YWx1ZXMsIHRoZSBzdGF0ZSBhbHNvXG4gKiBzdG9yZXMgdGhlIGBzb3VyY2VJbmRleGAgdmFsdWUuIFRoZSBgc291cmNlSW5kZXhgIHZhbHVlIGlzIGFuIGluY3JlbWVudGVkIHZhbHVlXG4gKiB0aGF0IGlkZW50aWZpZXMgd2hhdCBcInNvdXJjZVwiIChpLmUuIHRoZSB0ZW1wbGF0ZSwgYSBzcGVjaWZpYyBkaXJlY3RpdmUgYnkgaW5kZXggb3JcbiAqIGNvbXBvbmVudCkgaXMgY3VycmVudGx5IGFwcGx5aW5nIGl0cyBzdHlsaW5nIGJpbmRpbmdzIHRvIHRoZSBlbGVtZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0eWxpbmdTdGF0ZSB7XG4gIC8qKiBUaGUgZWxlbWVudCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQgKi9cbiAgZWxlbWVudDogUkVsZW1lbnR8bnVsbDtcblxuICAvKiogVGhlIGRpcmVjdGl2ZSBpbmRleCB0aGF0IGlzIGN1cnJlbnRseSBhY3RpdmUgKGAwYCA9PT0gdGVtcGxhdGUpICovXG4gIGRpcmVjdGl2ZUluZGV4OiBudW1iZXI7XG5cbiAgLyoqIFRoZSBzb3VyY2UgKGNvbHVtbikgaW5kZXggdGhhdCBpcyBjdXJyZW50bHkgYWN0aXZlIChgMGAgPT09IHRlbXBsYXRlKSAqL1xuICBzb3VyY2VJbmRleDogbnVtYmVyO1xuXG4gIC8qKiBUaGUgY2xhc3NlcyB1cGRhdGUgYml0IG1hc2sgdmFsdWUgdGhhdCBpcyBwcm9jZXNzZWQgZHVyaW5nIGVhY2ggY2xhc3MgYmluZGluZyAqL1xuICBjbGFzc2VzQml0TWFzazogbnVtYmVyO1xuXG4gIC8qKiBUaGUgY2xhc3NlcyB1cGRhdGUgYml0IGluZGV4IHZhbHVlIHRoYXQgaXMgcHJvY2Vzc2VkIGR1cmluZyBlYWNoIGNsYXNzIGJpbmRpbmcgKi9cbiAgY2xhc3Nlc0luZGV4OiBudW1iZXI7XG5cbiAgLyoqIFRoZSBzdHlsZXMgdXBkYXRlIGJpdCBtYXNrIHZhbHVlIHRoYXQgaXMgcHJvY2Vzc2VkIGR1cmluZyBlYWNoIHN0eWxlIGJpbmRpbmcgKi9cbiAgc3R5bGVzQml0TWFzazogbnVtYmVyO1xuXG4gIC8qKiBUaGUgc3R5bGVzIHVwZGF0ZSBiaXQgaW5kZXggdmFsdWUgdGhhdCBpcyBwcm9jZXNzZWQgZHVyaW5nIGVhY2ggc3R5bGUgYmluZGluZyAqL1xuICBzdHlsZXNJbmRleDogbnVtYmVyO1xufVxuXG4vLyB0aGVzZSB2YWx1ZXMgd2lsbCBnZXQgZmlsbGVkIGluIHRoZSB2ZXJ5IGZpcnN0IHRpbWUgdGhpcyBpcyBhY2Nlc3NlZC4uLlxuY29uc3QgX3N0YXRlOiBTdHlsaW5nU3RhdGUgPSB7XG4gIGVsZW1lbnQ6IG51bGwsXG4gIGRpcmVjdGl2ZUluZGV4OiAtMSxcbiAgc291cmNlSW5kZXg6IC0xLFxuICBjbGFzc2VzQml0TWFzazogLTEsXG4gIGNsYXNzZXNJbmRleDogLTEsXG4gIHN0eWxlc0JpdE1hc2s6IC0xLFxuICBzdHlsZXNJbmRleDogLTEsXG59O1xuXG5jb25zdCBCSVRfTUFTS19TVEFSVF9WQUxVRSA9IDA7XG5cbi8vIHRoZSBgMGAgc3RhcnQgdmFsdWUgaXMgcmVzZXJ2ZWQgZm9yIFttYXBdLWJhc2VkIGVudHJpZXNcbmNvbnN0IElOREVYX1NUQVJUX1ZBTFVFID0gMTtcblxuLyoqXG4gKiBSZXR1cm5zIChvciBpbnN0YW50aWF0ZXMpIHRoZSBzdHlsaW5nIHN0YXRlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBTdHlsaW5nIHN0YXRlIGlzIGFjY2Vzc2VkIGFuZCBwcm9jZXNzZWQgZWFjaCB0aW1lIGEgc3R5bGUgb3IgY2xhc3MgYmluZGluZ1xuICogaXMgZXZhbHVhdGVkLlxuICpcbiAqIElmIGFuZCB3aGVuIHRoZSBwcm92aWRlZCBgZWxlbWVudGAgZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBlbGVtZW50IGluIHRoZVxuICogc3RhdGUgdGhlbiB0aGlzIG1lYW5zIHRoYXQgc3R5bGluZyB3YXMgcmVjZW50bHkgY2xlYXJlZCBvciB0aGUgZWxlbWVudCBoYXNcbiAqIGNoYW5nZWQgaW4gY2hhbmdlIGRldGVjdGlvbi4gSW4gYm90aCBjYXNlcyB0aGUgc3R5bGluZyBzdGF0ZSBpcyBmdWxseSByZXNldC5cbiAqXG4gKiBJZiBhbmQgd2hlbiB0aGUgcHJvdmlkZWQgYGRpcmVjdGl2ZUluZGV4YCBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IGRpcmVjdGl2ZVxuICogaW5kZXggaW4gdGhlIHN0YXRlIHRoZW4gdGhpcyBtZWFucyB0aGF0IGEgbmV3IHNvdXJjZSBoYXMgaW50cm9kdWNlZCBpdHNlbGYgaW50b1xuICogdGhlIHN0eWxpbmcgY29kZSAob3IsIGluIG90aGVyIHdvcmRzLCBhbm90aGVyIGRpcmVjdGl2ZSBvciBjb21wb25lbnQgaGFzIHN0YXJ0ZWRcbiAqIHRvIGFwcGx5IGl0cyBzdHlsaW5nIGhvc3QgYmluZGluZ3MgdG8gdGhlIGVsZW1lbnQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGluZ1N0YXRlKGVsZW1lbnQ6IFJFbGVtZW50LCBkaXJlY3RpdmVJbmRleDogbnVtYmVyKTogU3R5bGluZ1N0YXRlIHtcbiAgaWYgKF9zdGF0ZS5lbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgX3N0YXRlLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIF9zdGF0ZS5kaXJlY3RpdmVJbmRleCA9IGRpcmVjdGl2ZUluZGV4O1xuICAgIF9zdGF0ZS5zb3VyY2VJbmRleCA9IGRpcmVjdGl2ZUluZGV4ID09PSBURU1QTEFURV9ESVJFQ1RJVkVfSU5ERVggPyAwIDogMTtcbiAgICBfc3RhdGUuY2xhc3Nlc0JpdE1hc2sgPSBCSVRfTUFTS19TVEFSVF9WQUxVRTtcbiAgICBfc3RhdGUuY2xhc3Nlc0luZGV4ID0gSU5ERVhfU1RBUlRfVkFMVUU7XG4gICAgX3N0YXRlLnN0eWxlc0JpdE1hc2sgPSBCSVRfTUFTS19TVEFSVF9WQUxVRTtcbiAgICBfc3RhdGUuc3R5bGVzSW5kZXggPSBJTkRFWF9TVEFSVF9WQUxVRTtcbiAgfSBlbHNlIGlmIChfc3RhdGUuZGlyZWN0aXZlSW5kZXggIT09IGRpcmVjdGl2ZUluZGV4KSB7XG4gICAgX3N0YXRlLmRpcmVjdGl2ZUluZGV4ID0gZGlyZWN0aXZlSW5kZXg7XG4gICAgX3N0YXRlLnNvdXJjZUluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIF9zdGF0ZTtcbn1cblxuLyoqXG4gKiBDbGVhcnMgdGhlIHN0eWxpbmcgc3RhdGUgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBieSBhbm90aGVyIGVsZW1lbnQncyBzdHlsaW5nIGNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldFN0eWxpbmdTdGF0ZSgpIHtcbiAgX3N0YXRlLmVsZW1lbnQgPSBudWxsO1xufVxuIl19